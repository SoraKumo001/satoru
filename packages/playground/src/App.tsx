import React, { useState, useEffect, useRef, useMemo } from "react";
import { Satoru, RequiredResource, createSatoruWorker } from "satoru";

const App: React.FC = () => {
  const [satoru, setSatoru] = useState<Satoru | null>(null);
  const [useWorker, setUseWorker] = useState<boolean>(false);
  const [html, setHtml] = useState<string>("");
  const [width, setWidth] = useState<number>(588);
  const [format, setFormat] = useState<"svg" | "png" | "pdf">("svg");
  const [assetList, setAssetList] = useState<string[]>([]);
  const [selectedAsset, setSelectedAsset] = useState<string>("");
  const [isRendering, setIsRendering] = useState<boolean>(false);
  const [renderResult, setRenderResult] = useState<string | Uint8Array | null>(
    null,
  );
  const [objectUrl, setObjectUrl] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const autoGeneratedRef = useRef<boolean>(false);

  const iframeRef = useRef<HTMLIFrameElement>(null);
  const workerRef = useRef<ReturnType<typeof createSatoruWorker> | null>(null);

  // Initialize Satoru
  useEffect(() => {
    Satoru.init()
      .then(setSatoru)
      .catch((e) => setError(`Failed to initialize Satoru: ${e.message}`));

    // Initialize Worker
    workerRef.current = createSatoruWorker(
      () =>
        new Worker(new URL("satoru/workers", import.meta.url), {
          type: "module",
        }),
      4,
    );

    // Get asset list
    const assetFiles = import.meta.glob("../../../assets/*.html", {
      query: "?url",
      import: "default",
    });
    setAssetList(Object.keys(assetFiles).map((path) => path.split("/").pop()!));

    return () => {
      workerRef.current?.close();
    };
  }, []);

  // Update iframe preview
  useEffect(() => {
    if (iframeRef.current) {
      const doc =
        iframeRef.current.contentDocument ||
        iframeRef.current.contentWindow?.document;
      if (doc) {
        doc.open();
        const baseTag = `<base href="${window.location.origin}${window.location.pathname}assets/">`;
        const htmlWithBase = html.includes("<head>")
          ? html.replace("<head>", `<head>${baseTag}`)
          : baseTag + html;
        doc.write(htmlWithBase);
        doc.close();
      }
    }
  }, [html]);

  // Handle asset selection
  useEffect(() => {
    const initialAsset =
      new URLSearchParams(window.location.search).get("asset") ||
      "01-layout.html";
    if (assetList.length > 0) {
      if (assetList.includes(initialAsset)) {
        loadAsset(initialAsset);
      } else if (!selectedAsset) {
        loadAsset(assetList[0]);
      }
    }
  }, [assetList]);

  const loadAsset = async (name: string) => {
    try {
      const resp = await fetch(`assets/${name}`);
      const text = await resp.text();
      setHtml(text);
      setSelectedAsset(name);

      const url = new URL(window.location.href);
      url.searchParams.set("asset", name);
      window.history.replaceState({}, "", url.toString());

      // Trigger conversion immediately if satoru is ready
      if (satoru) {
        handleConvert(text);
      }
    } catch (e) {
      console.error("Failed to load asset", e);
    }
  };

  const resourceResolver = async (r: RequiredResource) => {
    console.log(`[Satoru] Resolving ${r.type}: ${r.url}`);
    try {
      const url =
        r.url.startsWith("http") || r.url.startsWith("data:")
          ? r.url
          : `assets/${r.url}`;

      const resp = await fetch(url);
      if (!resp.ok) return null;

      const buf = await resp.arrayBuffer();
      return new Uint8Array(buf);
    } catch (e) {
      console.error(`Failed to resolve ${r.url}`, e);
      return null;
    }
  };

  const handleConvert = async (overrideHtml?: string) => {
    const currentHtml = overrideHtml !== undefined ? overrideHtml : html;
    if (!satoru || !currentHtml) return;

    setIsRendering(true);
    setError(null);

    // Clear resources for a clean state
    satoru.clearFonts();
    satoru.clearImages();

    if (objectUrl) {
      URL.revokeObjectURL(objectUrl);
      setObjectUrl(null);
    }

    try {
      let result: string | Uint8Array | null = null;

      if (useWorker && workerRef.current) {
        console.log("[Satoru] Rendering via Worker");
        result = await workerRef.current.execute("render", {
          html: currentHtml,
          width,
          format,
          baseUrl: `${window.location.origin}${window.location.pathname}assets/`,
        });
      } else {
        console.log("[Satoru] Rendering via Main Thread");
        result = await satoru.render({
          html: currentHtml,
          width,
          format,
          resolveResource: resourceResolver,
        });
      }

      setRenderResult(result);

      if (result instanceof Uint8Array) {
        const mimeType = format === "png" ? "image/png" : "application/pdf";
        const blob = new Blob([result.slice()], { type: mimeType });
        setObjectUrl(URL.createObjectURL(blob));
      }
    } catch (e: any) {
      console.error("Conversion failed:", e);
      setError(e.message);
    } finally {
      setIsRendering(false);
    }
  };

  // Auto-generate on initial load
  useEffect(() => {
    if (satoru && html && !autoGeneratedRef.current) {
      autoGeneratedRef.current = true;
      // Slight delay to ensure everything is settled
      const timer = setTimeout(() => {
        handleConvert();
      }, 500);
      return () => clearTimeout(timer);
    }
  }, [satoru, html]);

  const outputSource = useMemo(() => {
    if (!renderResult) return "";
    if (typeof renderResult === "string") return renderResult;

    // Binary to Base64
    let binary = "";
    const len = renderResult.byteLength;
    for (let i = 0; i < len; i++) {
      binary += String.fromCharCode(renderResult[i]);
    }
    return btoa(binary);
  }, [renderResult]);

  const handleDownload = () => {
    if (!renderResult) return;
    const mimeType =
      format === "svg"
        ? "image/svg+xml"
        : format === "png"
          ? "image/png"
          : "application/pdf";
    const content =
      typeof renderResult === "string" ? renderResult : renderResult.slice();
    const blob = new Blob([content as BlobPart], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `rendered.${format}`;
    a.click();
    setTimeout(() => URL.revokeObjectURL(url), 100);
  };

  if (error && !satoru) {
    return <div style={{ color: "red", padding: "50px" }}>{error}</div>;
  }

  return (
    <div
      style={{
        padding: "20px",
        fontFamily: "sans-serif",
        maxWidth: "1200px",
        margin: "0 auto",
        background: "#fafafa",
        minHeight: "100vh",
      }}
    >
      <header
        style={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          borderBottom: "2px solid #2196F3",
          marginBottom: "20px",
          paddingBottom: "10px",
        }}
      >
        <h2 style={{ color: "#2196F3", margin: 0 }}>
          Satoru Engine Playground (React)
        </h2>
        <div style={{ display: "flex", alignItems: "center", gap: "10px" }}>
          <label
            style={{
              cursor: "pointer",
              display: "flex",
              alignItems: "center",
              gap: "5px",
            }}
          >
            <input
              type="checkbox"
              checked={useWorker}
              onChange={(e) => setUseWorker(e.target.checked)}
            />
            Use Multi-threading (Workers)
          </label>
          {!satoru && (
            <span style={{ color: "#666" }}>Initializing Engine...</span>
          )}
        </div>
      </header>

      <div style={{ display: "flex", gap: "20px", marginBottom: "20px" }}>
        <fieldset
          style={{
            flex: 1,
            padding: "15px",
            border: "1px solid #ddd",
            borderRadius: "8px",
            background: "white",
          }}
        >
          <legend style={{ fontWeight: "bold" }}>Rendering Options</legend>
          <div
            style={{ display: "flex", flexDirection: "column", gap: "10px" }}
          >
            <label>
              Width:{" "}
              <input
                type="number"
                value={width}
                onChange={(e) => setWidth(parseInt(e.target.value) || 0)}
                style={{ width: "80px" }}
              />
            </label>
            <label>
              Format:{" "}
              <select
                value={format}
                onChange={(e) =>
                  setFormat(e.target.value as "svg" | "png" | "pdf")
                }
                style={{ padding: "2px 5px", borderRadius: "4px" }}
              >
                <option value="svg">SVG (Vector)</option>
                <option value="png">PNG (Raster)</option>
                <option value="pdf">PDF (Document)</option>
              </select>
            </label>
          </div>
        </fieldset>

        <fieldset
          style={{
            flex: 1,
            padding: "15px",
            border: "1px solid #ddd",
            borderRadius: "8px",
            background: "white",
          }}
        >
          <legend style={{ fontWeight: "bold" }}>Load Sample Assets</legend>
          <select
            value={selectedAsset}
            onChange={(e) => loadAsset(e.target.value)}
            style={{
              padding: "5px",
              borderRadius: "4px",
              border: "1px solid #ccc",
              width: "100%",
            }}
          >
            <option value="">-- Select Asset --</option>
            {assetList.map((asset) => (
              <option key={asset} value={asset}>
                {asset}
              </option>
            ))}
          </select>
        </fieldset>
      </div>

      <div style={{ marginBottom: "15px" }}>
        <h3>HTML Input:</h3>
        <textarea
          value={html}
          onChange={(e) => setHtml(e.target.value)}
          style={{
            width: "100%",
            height: "150px",
            fontFamily: "monospace",
            padding: "10px",
            borderRadius: "4px",
            border: "1px solid #ccc",
            boxSizing: "border-box",
          }}
        />
      </div>

      <button
        onClick={() => handleConvert()}
        disabled={isRendering || !satoru}
        style={{
          padding: "15px 30px",
          fontSize: "20px",
          cursor: "pointer",
          background: isRendering ? "#ccc" : "#2196F3",
          color: "white",
          border: "none",
          borderRadius: "4px",
          width: "100%",
          fontWeight: "bold",
          marginBottom: "20px",
          boxShadow: "0 4px 6px rgba(33, 150, 243, 0.3)",
        }}
      >
        {isRendering ? "Processing..." : "Generate Output"}
      </button>

      {error && (
        <div
          style={{
            padding: "10px",
            background: "#ffebee",
            color: "#c62828",
            borderRadius: "4px",
            marginBottom: "20px",
          }}
        >
          {error}
        </div>
      )}

      <div
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(2, minmax(0, 1fr))",
          gap: "20px",
          marginBottom: "20px",
        }}
      >
        <div>
          <h3>HTML Live Preview (iframe):</h3>
          <div
            style={{
              border: "1px solid #ccc",
              borderRadius: "4px",
              height: "800px",
              background: "white",
              overflow: "hidden",
              boxSizing: "border-box",
            }}
          >
            <iframe
              ref={iframeRef}
              title="preview"
              style={{ width: "100%", height: "100%", border: "none" }}
            />
          </div>
        </div>

        <div>
          <div
            style={{
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
            }}
          >
            <h3>{format.toUpperCase()} Render Preview:</h3>
            {renderResult && (
              <button
                onClick={handleDownload}
                style={{
                  background: "#FF9800",
                  color: "white",
                  border: "none",
                  padding: "6px 15px",
                  cursor: "pointer",
                  borderRadius: "4px",
                }}
              >
                Download
              </button>
            )}
          </div>
          <div
            style={{
              border: "1px solid #ddd",
              background: "white",
              height: "800px",
              display: "flex",
              overflow: "auto",
              boxSizing: "border-box",
              justifyContent: "center",
              position: "relative",
            }}
          >
            {isRendering && (
              <div
                style={{
                  position: "absolute",
                  top: 0,
                  left: 0,
                  right: 0,
                  bottom: 0,
                  background: "rgba(255, 255, 255, 0.7)",
                  display: "flex",
                  justifyContent: "center",
                  alignItems: "center",
                  zIndex: 10,
                  fontWeight: "bold",
                  color: "#2196F3",
                  backdropFilter: "blur(2px)",
                }}
              >
                Rendering {format.toUpperCase()}...
              </div>
            )}
            {!renderResult && !isRendering && (
              <div style={{ color: "#999", marginTop: "200px" }}>
                Result will appear here
              </div>
            )}
            {renderResult && format === "svg" && (
              <div
                dangerouslySetInnerHTML={{ __html: renderResult as string }}
              />
            )}
            {objectUrl && format === "png" && (
              <img
                src={objectUrl}
                alt="render result"
                style={{
                  maxWidth: "100%",
                  height: "auto",
                  boxShadow: "0 2px 10px rgba(0,0,0,0.1)",
                }}
              />
            )}
            {objectUrl && format === "pdf" && (
              <embed
                src={objectUrl}
                type="application/pdf"
                style={{ width: "100%", height: "100%", border: "none" }}
              />
            )}
          </div>
        </div>
      </div>

      <div>
        <h3>Output Source {format !== "svg" ? "(Base64)" : ""}:</h3>
        <textarea
          value={outputSource}
          readOnly
          style={{
            width: "100%",
            height: "300px",
            fontFamily: "monospace",
            padding: "10px",
            borderRadius: "4px",
            border: "1px solid #ccc",
            boxSizing: "border-box",
            background: "#fdfdfd",
          }}
        />
      </div>
    </div>
  );
};

export default App;
